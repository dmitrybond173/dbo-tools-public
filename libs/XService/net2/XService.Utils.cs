/*
 * Lot of simple utilities to facilitate programming in .NET.
 * Written by Dmitry Bond. at Jun 14, 2006
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.Globalization;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using XService.Security;

namespace XService.Utils
{
    /// <summary>Base class for all exceptions generated by code in XService.Net2 assmebly</summary> 
    public class XServiceError : Exception
    {
        public XServiceError(string message) : base (message) { }
    }

    /// <summary>
    /// Class to store information about one parsed command line argument.
    /// </summary>
    public class ProgramArgument
    {
        /// <summary>types of command line argument </summary>
        public enum EArgumentType
        {
            /// <summary>command line argument is a file. Filename expected to be in ArgValue</summary>
            File,
            /// <summary>command line argument is an option. Option names will be in ArgName, if option has value it will be in ArgValue (otherwise ArgValue is null)</summary>
            Option, 
        }

        /// <summary>type of command line argument </summary>
        public EArgumentType ArgType;

        /// <summary>name of command line argument (in case when argument is an option) </summary>
        public string ArgName;

        /// <summary>filename or value of option</summary>
        public string ArgValue;

        public override string ToString()
        {
            return string.Format("{0}{3}{2}{4}{1}",
                (ArgType == EArgumentType.Option ? "/" : "["),
                (ArgType == EArgumentType.Option ? "" : "]"),
                (ArgType == EArgumentType.Option ? "=" : ""),
                (ArgName != null ? ArgName : ""), 
                (ArgValue != null ? ArgValue : "")
                );
        }

        /// <summary>Search argument with specified name in specified list</summary>
        /// <param name="pList">List to search argument in</param>
        /// <param name="pArgName">Argument name</param>
        /// <returns>Index of found argument or -1 when not found</returns>
        public static int IndexOfArgument(List<ProgramArgument> pList, string pArgName)
        {
            for (int i = 0; i < pList.Count; i++)
            {
                if (StrUtils.IsSameText(pList[i].ArgName, pArgName))
                    return i;
            }
            return -1;
        }
    }


    /// <summary>Set of service routinues to operate bytes on a bit level</summary> 
    public sealed class BitUtils
    {
        /// <summary>encoding table for internal encoding algorithm </summary> 
        public static string benj_encoding_table = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_~";

        /// <summary>encoding table for BASE64 (MIME) encoding algorithm</summary>
        public static string base64_encoding_table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        /// <summary>encoding table for UU encoding algorithm</summary> 
        public static string uue_encoding_table = "`!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";

        /// <summary>current encoding table for UU encoding algorithm</summary> 
        public static string current_encoding_table = base64_encoding_table;

        /// <summary>type of bytes encoding - how many bits per encoding symbol it should use</summary> 
        public enum EEncodeBase { x4bit, x5bit, x6bit };

        /// <summary>
        /// Interpret specified array of bytes as array of N-bit sized items and extract J-i item from it
        /// </summary>
        /// <param name="pArrOfBits">array of bytes to interpret as array of N-bit sized items</param>
        /// <param name="pItemIndex">index of item to extract</param>
        /// <param name="pBitsPerItem">bits per item. Max value is 32, it cannot operate items longer than 32-bit size</param>
        /// <returns>Extracted value.</returns>
        public static uint get_x_bits(byte[] pArrOfBits, int pItemIndex, byte pBitsPerItem)
        {
            int bis = (pItemIndex * pBitsPerItem); // {bi - bit, by - byte} + {s - start, e - end}
            int bie = bis + pBitsPerItem;
            int bys = bis >> 3;

            uint nValue = 0;
            byte bMaskV = 1; // A - mask for Bits Array, V - mask for Value
            byte bMaskA = (byte)(1 << (bis % 8));
            while (bis < bie)
            {
                byte b = ((bys < pArrOfBits.Length) ? pArrOfBits[bys] : (byte)0);
                if ((b & bMaskA) == bMaskA)
                    nValue |= bMaskV;

                if (bMaskA == 0x80)
                {
                    bMaskA = 1;
                    bys++;
                }
                else
                    bMaskA <<= 1;

                bMaskV <<= 1;
                bis++;
            }

            return nValue;
        }

        /// <summary>
        /// Interpret specified array of bytes as array of N-bit sized items and set J-i item in it
        /// </summary>
        /// <param name="pArrOfBits">array of bytes to interpret as array of N-bit sized items</param>
        /// <param name="pItemIndex">index of item to extract</param>
        /// <param name="pBitsPerItem">bits per item. Max value is 32, it cannot operate items longer than 32-bit size</param>
        /// <returns>Extracted value.</returns>
        public static void set_x_bits(byte[] pArrOfBits, int pItemIndex, byte pBitsPerItem, uint pValue)
        {
            int bis = (pItemIndex * pBitsPerItem); // {bi - bit, by - byte} + {s - start, e - end}
            int bie = bis + pBitsPerItem;
            int bys = bis >> 3;

            byte bMaskV = 1; // A - mask for Bits Array, V - mask for Value
            byte bMaskA = (byte)(1 << (bis % 8));
            while (bis < bie)
            {
                if (bys >= pArrOfBits.Length) break;

                pArrOfBits[bys] &= (byte)~bMaskA;
                if ((pValue & bMaskV) == bMaskV)
                    pArrOfBits[bys] |= bMaskA;

                if (bMaskA == 0x80)
                {
                    bMaskA = 1;
                    bys++;
                }
                else
                    bMaskA <<= 1;

                bMaskV <<= 1;
                bis++;
            }
        }

        /// <summary>
        /// Interpret specified array of bytes as array of N-bit sized elements (bit sizes vary as 4, 5, 6 bits).
        /// Encode every of such N-bit sized element as a ASCII character using string specified in current_encoding_table.
        /// </summary>
        /// <param name="pBase">Defines size of element in bits</param>
        /// <param name="pSrc">Source array of bytes to encode</param>
        /// <param name="pChekSumDest">Output. CRC32 of source array of bytes</param>
        /// <returns>Returns text string which is represending encoded array of bytes</returns>
        public static string x_encode(EEncodeBase pBase, byte[] pSrc, out uint pChekSumDest)
        {
            pChekSumDest = SecurityUtils.CalculateCRC32(0, pSrc, 0, pSrc.Length);

            int tableCharsCount;
            byte en_base = encodeBaseToLen(pBase, out tableCharsCount);

            int count = pSrc.Length << 3; // number of bits in bytes array
            count = (count / en_base); // number of N-bit sized items
            if ((count % en_base) != 0)
                count++;

            string result = "";
            for (int i=0; i<count; i++)
            {
              byte oneItem = (byte)get_x_bits(pSrc, i, en_base);
              result += current_encoding_table[oneItem];
            }

            return result;
        }

        /// <summary>
        /// Interpret specified text as previously encoded array N-bit sized elements. Encoding was done according to current_encoding_table.
        /// So, it will decode every character as presentation of N-bit sized element in some data buffer and it will reconstruct that buffer then.
        /// </summary>
        /// <param name="pBase">Defines size of element in bits</param>
        /// <param name="pSrcText">Source text to decode back to binary buffer</param>
        /// <param name="pBuffer">Output. Reconstructed array of bytes</param>
        /// <param name="pBytesCount">Output. Return size of reconstructed array of bytes</param>        /// 
        /// <param name="pChekSumDest">Output. CRC32 of reconstructed array of bytes</param>
        /// <returns>Returns true in case when buffer reconstruction was successfull</returns>
        public static bool x_decode(EEncodeBase pBase, string pSrcText, out byte[] pBuffer, ref int pBytesCount, out uint pChekSumDest)
        {
            pChekSumDest = 0;
            pBytesCount = 0;
            pBuffer = null;

            int tableCharsCount;
            byte baseLen = encodeBaseToLen(pBase, out tableCharsCount);
            pBytesCount = (baseLen * pSrcText.Length) >> 3;
            pBuffer = new byte[pBytesCount];
            Array.Clear(pBuffer, 0, pBuffer.Length);
            for (int i = 0; i < pSrcText.Length; i++)
            {
                int n = current_encoding_table.IndexOf(pSrcText[i]);
                if (n < 0 || n >= tableCharsCount) return false;
                set_x_bits(pBuffer, i, baseLen, (uint)n);
            }
            pChekSumDest = SecurityUtils.CalculateCRC32(0, pBuffer, 0, pBuffer.Length);
            return true;
        }

        private static byte encodeBaseToLen(EEncodeBase pBase, out int pTableCharsCount)
        {
            byte en_base = 6;
            pTableCharsCount = 64;
            switch (pBase)
            {
                case EEncodeBase.x4bit: en_base = 4; pTableCharsCount = 16; break;
                case EEncodeBase.x5bit: en_base = 5; pTableCharsCount = 32; break;
                case EEncodeBase.x6bit: en_base = 6; pTableCharsCount = 64; break;
            }
            return en_base;
        }

        /// <summary>Align integer number to specified bound. You can use it to align sizes of memory buffers, etc.</summary>
        public static int AlignTo(int pValue, int pBound)
        {
            return ((pValue + pBound - 1) / pBound) * pBound; 
        }

        /// <summary>Swap even and odd bits in specified 32bit number</summary>
        public static uint I32_bitSwap1(uint V)
        {
            return ((uint)((V & 0xAAAAAAAA) >> 1) | (uint)((V & 0x55555555) << 1));
        }

        /// <summary>Swap even and odd pairs of bits in specified 32bit number</summary>
        public static uint I32_bitSwap2(uint V)
        {
            return ((uint)((V & 0xCCCCCCCC) >> 2) | (uint)((V & 0x33333333) << 2));
        }

        /// <summary>Swap bits in 32bit number by the following rule (rule shown for bits in 1 byte): 01234567 -> 04561237</summary>
        public static uint I32_bitSwap3(uint V)
        {
            return ((uint)(V & 0x81818181) | (uint)((V & 0x70707070) >> 3) | (uint)((V & 0x0E0E0E0E) << 3));
        }

        /// <summary>Swap bits in 32bit number by the following rule (rule shown bits in 1 byte): 01234567 -> 45670123</summary>
        public static uint I32_bitSwap4(uint V)
        {
            return ((uint)((V & 0xF0F0F0F0) >> 4) | (uint)((V & 0x0F0F0F0F) << 4));
        }

        /// <summary>Swap even and odd bytes in 32bit number</summary>
        public static uint I32_bitSwap8(uint V)
        {
            return ((uint)((V & 0xFF00FF00) >> 8) | (uint)((V & 0x00FF00FF) << 8));
        }

        /// <summary>Swap even and odd words in 32bit number</summary>
        public static uint I32_bitSwap16(uint V)
        {
            return ((uint)((V & 0xFFFF0000) >> 16) | (uint)((V & 0x0000FFFF) << 16));
        }

        /// <summary>Rotate bits in 32 bit number (showing on a bits for 1 byte: 01234567 -> 76543210)</summary>
        public static uint I32_bitRotate(uint V)
        {
            return I32_bitSwap1(I32_bitSwap2(I32_bitSwap4(I32_bitSwap8(I32_bitSwap16(V)))));
        }

        /// <summary>Return index of first non-zero bit in specified 32 bit uint number (bits indexes starts with 0, max value is 31, when not found returns -1)</summary>
        public static int FirstNonZeroBit(uint V)
        {
            int bitIndex = 0;
            uint mask = 1;
            while ((V & mask) == 0 && bitIndex <= 31)
            {
                bitIndex++;
                mask <<= 1;
            }
            if (bitIndex > 31)
                return -1;
            return bitIndex;
        }

        /// <summary>Pack DateTime into 64 bit integer value</summary>
        /// <param name="pTs">DateTime to pack</param>
        /// <returns>64 bit integer value representing the source DateTime</returns>
        public static long PackDateTime(DateTime pTs)
        {
            /*
            typedef struct tag_XVarDateTime
            {
              unsigned year   : 12;     // number from 0 to 4.095 
              unsigned month  :  4;     // number from 1 to 12 (limited by 15) 
              unsigned day    :  5;     // number from 1 to 31 (limited by 31) 
              unsigned hour   :  5;     // number from 0 to 23 (limited by 31) 
              unsigned minute :  6;     // number from 0 to 59 (limited by 63) 
              unsigned second :  6;     // number from 0 to 59 (limited by 63) 
              unsigned microseconds: 20;// number from 0 to 999.999 (limited by 1.048.575) 
              unsigned subtype:  5;     // datatime subtype id 
            }
            XVarDateTime;  // full date time stamp (with fraction 6 (microseconds)) 
            */
            
            /*
             2019-07-21,12:45:33.123456
             x(y)= 7E3
             x(ym)= 77E3
             x(ymd)= 1577E3
             x(ymdh)= 19577E3
             x(ymdhn)= B59577E3
             x(ymdhns)= 21B59577E3
             x(ymdhnsf)= 789021B59577E3 => 00781E21B59577E3
             *         00781E21B59577E3
             */

            long result = 0;
            result |= ((long)(pTs.Year & 0x0FFF));
            result |= ((long)(pTs.Month & 0x0F) << 12);
            result |= ((long)(pTs.Day & 0x1F) << 16);

            result |= ((long)(pTs.Hour & 0x1F) << 21);
            result |= ((long)(pTs.Minute & 0x3F) << 26);
            result |= ((long)(pTs.Second & 0x3F) << 32);
            result |= ((long)((pTs.Millisecond * 1000) & 0x0FFFFF) << 38);

            return result;
        }

        /// <summary>Unpack DateTime from 64 bit integer value</summary>
        /// <param name="pValue">64 bit integer value to extract DateTime from</param>
        /// <returns>DateTime in case of success, otherwise it will return DateTime.MinValue</returns>
        public static DateTime UnpackDateTime(long pValue)
        {
            int y, m, d, h, n, s, f;
            y = (int)(pValue & 0x0FFF);
            m = (int)((pValue >> 12) & 0x0F);
            d = (int)((pValue >> 16) & 0x1F);
            h = (int)((pValue >> 21) & 0x1F);
            n = (int)((pValue >> 26) & 0x3F);
            s = (int)((pValue >> 32) & 0x3F);
            f = (int)((pValue >> 38) & 0x0FFFFF);
            bool isValid = (1 <= y && y <= 9999) && (1 <= m && m <= 12) && (1 <= d && d <= 31)
                && (0 <= h && h <= 23) && (0 <= n && n <= 59) && (0 <= s && s <= 59) && (0 <= f && f <= 999);
            if (!isValid)
                return DateTime.MinValue;

            DateTime ts = new DateTime(y, m, d, h, n, s, f / 1000);
            return ts;
        }

        public static ulong TsToLong(DateTime pTs)
        {
            // year:12, month:4, day:5, hour:5, minute:6, second:6, microseconds:20; subtype:5 = 58bit
            ulong result = 0;
            int bits = 58;
            bits -= 12; result |= ((ulong)(pTs.Year & 0x0FFF) << bits);
            bits -= 4; result |= ((ulong)(pTs.Month & 0x0F) << bits);
            bits -= 5; result |= ((ulong)(pTs.Day & 0x1F) << bits);
            bits -= 5; result |= ((ulong)(pTs.Hour & 0x1F) << bits);
            bits -= 6; result |= ((ulong)(pTs.Minute & 0x03F) << bits);
            bits -= 6; result |= ((ulong)(pTs.Second & 0x03F) << bits);
            bits -= 20; result |= ((ulong)((pTs.Millisecond * 1000) & 0xFFFFF) << bits);
            return result;
        }

        public static DateTime LongToTs(ulong pValue)
        {
            // year:12, month:4, day:5, hour:5, minute:6, second:6, microseconds:20; subtype:5 = 58bit
            int bits = 58;
            int y, m, d, h, n, s, f;
            bits -= 12; y = (int)((pValue >> bits) & 0x0FFF);
            bits -= 4; m = (int)((pValue >> bits) & 0xF);
            bits -= 5; d = (int)((pValue >> bits) & 0x1F);
            bits -= 5; h = (int)((pValue >> bits) & 0x1F);
            bits -= 6; n = (int)((pValue >> bits) & 0x3F);
            bits -= 6; s = (int)((pValue >> bits) & 0x3F);
            bits -= 20; f = (int)(((pValue >> bits) & 0xFFFFF) / 1000);
            DateTime result = new DateTime(y, m, d, h, n, s, f);
            return result;
        }
    }


    /// <summary>
    /// CommonUtils
    /// </summary>
    public sealed class CommonUtils
    {
        /// <summary>All trace logging of XService.Net2 assmebly should use this TraceSwitch</summary>
        public static TraceSwitch TrcLvl = new TraceSwitch("XService", "XService");

        /// <summary>Write to log current values of TraceSwitches</summary>
        /// <param name="pCaption">ID caption of record in log</param>
        public static void LogTraceConfig(string pCaption)
        {
            System.Configuration.Configuration cfg = ConfigurationManager.OpenExeConfiguration(TypeUtils.ApplicationExecutableFullPath);
            if (!cfg.HasFile)
            {
                Trace.WriteLine("ERR: Application has no CONFIG file!");
                return;
            }
            XmlDocument dom = new XmlDocument();
            dom.Load(cfg.FilePath);
            XmlNodeList switchesList = dom.SelectNodes("/configuration/system.diagnostics/switches/add");
            if (switchesList.Count == 0)
            {
                Trace.WriteLine("ERR: Application CONFIG file has no TraceSwitches defined!");
                return;
            }

            int idx = 0;
            string result = string.Format("{0} trace switches:", switchesList.Count);
            foreach (XmlNode node in switchesList)
            {
                idx++;
                XmlNode attr = ((XmlElement)node).GetAttributeNode("name");
                if (attr != null)
                {
                    string name = attr.Value;
                    TraceSwitch lvl = new TraceSwitch(name, name);
                    result += string.Format("\n\t#{0}: {1} = {2}({3})", idx, name, lvl.Level, (int)lvl.Level);
                }
            }
            Trace.WriteLine(string.Format("TraceLog[{0}]: ", pCaption) + result);
        }

        /// <summary>
        /// Present array of bytes as string with a list of hexadeciaml numbers.
        /// </summary>
        /// <param name="pArr">Array of bytes</param>
        /// <returns>String with a list of hexadeciaml numbers</returns>
        public static string Bytes2Hex(byte[] pArr)
        {
            return StrUtils.Bytes2Hex(pArr, null);
        }

        /// <summary>
        /// Parse specified command line arguments using standard parer.
        /// </summary>
        /// <param name="pArgs">Source command line arguments to parse</param>
        /// <param name="pTargetArgsList">Target list to store parsed command line arguments in form of objects</param>
        /// <returns>Number of successfully parsed arguments added to target list</returns>
        public static int ParseCmdLine(string[] pArgs, List<ProgramArgument> pTargetArgsList)
        {
            if (pArgs == null || pArgs.Length == 0) return 0;
            if (pTargetArgsList == null) return -1;

            int savedCount = pTargetArgsList.Count;
            foreach (string arg in pArgs)
            {
                string pn = arg.Trim(" \t".ToCharArray());
                if (pn.StartsWith("-") || pn.StartsWith("/"))
                {
                    string pv = null;

                    bool isLongOpt = pn.StartsWith("--");
                    if (isLongOpt)
                        pn = pn.Remove(0, 2);
                    else
                        pn = pn.Remove(0, 1);

                    int p = pn.IndexOf('=');
                    if (p < 0) p = pn.IndexOf(':');
                    if (p >= 0)
                    {
                        pv = pn.Remove(0, p + 1);
                        pn = pn.Remove(p, pn.Length - p);
                    }
                    
                    pn = pn.Trim().ToLower();
                    int idx = ProgramArgument.IndexOfArgument(pTargetArgsList, pn);
                    pTargetArgsList.Add(new ProgramArgument() { ArgType = ProgramArgument.EArgumentType.Option, ArgName = pn, ArgValue = pv });
                    if (idx >= 0)
                        pTargetArgsList.RemoveAt(idx);
                }
                else
                {
                    int idx = ProgramArgument.IndexOfArgument(pTargetArgsList, pn);
                    pTargetArgsList.Add(new ProgramArgument() { ArgType = ProgramArgument.EArgumentType.File, ArgValue = pn });
                    if (idx >= 0)
                        pTargetArgsList.RemoveAt(idx);
                }
            }
            return pTargetArgsList.Count - savedCount;
        }

        /// <summary>Prepare string representing names bit-flag options according to specified Enum type</summary>
        /// <param name="pFlagsEnumType">Enum type of bit-flag options</param>
        /// <param name="pFlagsValue">Orginary value of bit-flag options</param>
        /// <returns>Semicolon-separated list of bit-flag option names specified in pFlagsValue</returns>
        public static string BuildOptionsStr(uint pFlagsValue, Type pFlagsEnumType)
        {
            string txt = "";
            string[] flagNames = Enum.GetNames(pFlagsEnumType);
            Array flagValues = Enum.GetValues(pFlagsEnumType);
            for (int i = 0; i < flagNames.Length; i++)
            {
                uint flag = (uint)flagValues.GetValue(i);
                if (flag == 0 && pFlagsValue == 0) txt = flagNames[i];
                if ((pFlagsValue & flag) == flag) txt += (flagNames[i] + ";");
            }
            return txt.Trim(";".ToCharArray());
        }

        /// <summary>Parse string representing bit-flag options according to specified Enum type</summary>
        /// <param name="pText">String to parse</param>
        /// <param name="pFlagsEnumType">Enum type of bit-flag options</param>
        /// <param name="pFlagsValue">Output: orginary value of bit-flag options recognized after input string parsing</param>
        /// <returns>Returns true when there were no errors</returns>
        public static bool ParseOptionsStr(string pText, Type pFlagsEnumType, out uint pFlagsValue)
        {
            pFlagsValue = 0;
            bool isOk = true;
            string[] items = pText.Replace(',', ';').Split(';');
            foreach (string item in items)
            {
                string s = item.Trim(StrUtils.CH_SPACES);
                if (string.IsNullOrEmpty(s)) continue;
                try
                {
                    object v = Enum.Parse(pFlagsEnumType, s, true);
                    uint opt = (uint)(int)v;
                    pFlagsValue |= opt;
                }
                catch //(Exception exc)
                {
                    isOk = false;
                }
            }
            return isOk;
        }

        /// <summary>Parse windows userId (one of possible formats - "domain\user" or "user@domain")</summary>
        /// <param name="pUserId">UserId to parse</param>
        /// <param name="pUsername">Output. User name</param>
        /// <param name="pDomain">Output. Domain name</param>
        /// <returns>Returns true when userIs successfully parsed</returns>
        public static bool ParseUserId(string pUserId, out string pUsername, out string pDomain)
        {
            pUsername = null;
            pDomain = null;

            string p1 = null, p2 = null;
            char ch = '\\';
            int p = pUserId.IndexOf(ch);
            if (p < 0)
            {
                ch = '@';
                p = pUserId.IndexOf(ch);
            }
            if (p < 0) ch = '\0';
            if (p >= 0)
            {
                // _12345678
                // dom\uzver
                p1 = pUserId.Substring(0, p);
                p2 = pUserId.Remove(0, p + 1);
            }
            if (ch == '\\') // domain\user
            {
                pDomain = p1;
                pUsername = p2;
            }
            if (ch == '@') // user@domain
            {
                pDomain = p2;
                pUsername = p1;
            }

            return (ch != 0);
        }

        /// <summary>Compare 2 arrays</summary>
        public static int CompareArrays(Array pA1, Array pA2)
        {
            IEnumerator en1 = pA1.GetEnumerator();
            IEnumerator en2 = pA2.GetEnumerator();
            while (en1.MoveNext())
            {
                if (!en2.MoveNext()) return 1;
                object obj1 = en1.Current;
                object obj2 = en2.Current;
                if (obj1 == null && obj2 != null) return -1;
                if (obj1 != null && obj2 == null) return 1;
                bool isCmp1 = (obj1 is IComparable);
                bool isCmp2 = (obj2 is IComparable);
                if (isCmp1 && !isCmp2) return 1;
                if (!isCmp1 && isCmp2) return -1;
                IComparable ic1 = (IComparable)obj1;
                IComparable ic2 = (IComparable)obj2;
                int result = ic1.CompareTo(ic2);
                if (result != 0) return result;
            }
            return 0;
        }

        /// <summary>Dispose all objects in list</summary>
        public static void DisposeObjects(ArrayList pList)
        {
            for (int i = 0; i < pList.Count; i++)
            {
                object obj = pList[i];
                pList[i] = null;
                DisposeObject(ref obj);
            }
            pList.Clear();
        }

        /// <summary>Dispose all objects in list</summary>
        public static void DisposeObjects<T>(List<T> pList)
        {
            for (int i = 0; i < pList.Count; i++)
            {
                object obj = pList[i];
                pList[i] = default(T); // pEmptyObj;
                DisposeObject(ref obj);
            }
            pList.Clear();
        }

        /// <summary>Dispose one specified object</summary>
        public static void DisposeObject(object pObj)
        {
            DisposeObject(ref pObj);
        }

        /// <summary>Dispose one specified object and set object pointer to null</summary>
        public static void DisposeObject(ref object pObj)
        {
            if (pObj != null)
            {
                object tmpObj = pObj;
                pObj = null;
                if (tmpObj is IDisposable)
                {
                    ((IDisposable)tmpObj).Dispose();
                }
                tmpObj = null;
            }
        }

        /// <summary>Call event handler of specified event (by name) for specified object</summary>
        public static bool RaiseEvent(object AObject, string AEventName, params object[] args)
        {
            EventInfo ei = AObject.GetType().GetEvent(AEventName);
            if (ei == null) 
                throw new XServiceError(String.Format(
                    "Object [{0}] has not [{1}] event!", AObject.GetType().ToString(), AEventName));

            MethodInfo mi = ei.GetRaiseMethod(true);
            if (mi == null) 
                return false; 

            mi.Invoke(AObject, args);

            return true;
        }

        /// <summary>Returns string consists of system information parameters - computer name, user name, app dir, .NET version, etc</summary>
        public static string HostInfoStamp()
        {
            Assembly asm = Assembly.GetEntryAssembly();
            if (asm == null) 
                asm = Assembly.GetExecutingAssembly();

            StringBuilder sb = new StringBuilder(400);
            sb.AppendFormat("Comp:{0}; ", Environment.MachineName);
            sb.AppendFormat("WinUser:{0}\\{1}, intractv={2}; ", Environment.UserDomainName, Environment.UserName, Environment.UserInteractive);
            sb.AppendFormat("App:{0}, ver={1}, dir={2}, mem={3}; ", asm.CodeBase, TypeUtils.ApplicationVersionStr, Environment.CurrentDirectory, Environment.WorkingSet.ToString("N0"));
            sb.AppendFormat("Sys:{0}, .NET {1}, {2} cpu, dir={3}; ", Environment.OSVersion, Environment.Version, Environment.ProcessorCount, Environment.SystemDirectory);
            sb.AppendFormat("culture={0}/ui={1}(thrd={2}/ui={3}); ", CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture, Thread.CurrentThread.CurrentCulture, Thread.CurrentThread.CurrentUICulture);

            return sb.ToString();

            /*
            return string.Format("Comp:{0}; WinUser:{1}\\{2}, intractv={3}; App:{4}, dir={5}, mem={6}; Sys:{7}, .NET {8}, {9} cpu, dir={10}; culture={11}/ui={12}(thrd={13}/ui={14});",
                Environment.MachineName, 
                Environment.UserDomainName, Environment.UserName, Environment.UserInteractive,
                asm.CodeBase, Environment.CurrentDirectory, Environment.WorkingSet.ToString("N0"),
                Environment.OSVersion, Environment.Version, Environment.ProcessorCount, Environment.SystemDirectory,
                CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture,
                Thread.CurrentThread.CurrentCulture, Thread.CurrentThread.CurrentUICulture
                );
            */
        }

        /// <summary>Default hashcode type to use</summary>
        public static string HASH_CODE_TYPE = "MD5";

        /// <summary>Calculate hash code of specified string. Type of hashcode to use specified in HASH_CODE_TYPE static class member</summary>
        /// <returns>Hexadecimal string representing hashcode</returns>
        public static string CalculateHash(string pText)
        {
            return CalculateHashEx(pText, HASH_CODE_TYPE, null);
        }

        /// <summary>Calculate specified hash code type of bytes of specified string, bytes of string are discovered using specified text encoding</summary>
        /// <returns>Hexadecimal string representing hashcode</returns>
        public static string CalculateHashEx(string pText, string pHashName, Encoding pTextEncoding)
        {
            if (pTextEncoding == null)
                pTextEncoding = Encoding.UTF8;
            using (HashAlgorithm engine = HashAlgorithm.Create(pHashName))
            {
                byte[] hash = CalculateHashBytesEx(pTextEncoding.GetBytes(pText), pHashName);
                string txt = "";
                for (int i = 0; i < hash.Length; i++)
                {
                    txt += hash[i].ToString("X2");
                }
                return txt;
            }
        }

        /// <summary>Calculate specified hash code type of specified array of bytes</summary>
        /// <returns>Array of bytes of hashcode</returns>
        public static byte[] CalculateHashBytesEx(byte[] pBuffer, string pHashName)
        {
            using (HashAlgorithm engine = HashAlgorithm.Create(pHashName))
            {
                engine.Initialize();
                byte[] hash = engine.ComputeHash(pBuffer);
                return hash;
            }
        }

        /// <summary>Return string consists of class name + "@" + object HashCode</summary>
        public static string ObjectToStr(object pObj)
        {
            if (pObj == null)
                return "(null)";
            else
                return string.Format("[{0}@{1}]", pObj.GetType().ToString(), pObj.GetHashCode());
        }

        /// <summary>Swap 2 values</summary>
        public static void Swap<T>(ref T pV1, ref T pV2)
        {
            T tmp = pV1;
            pV1 = pV2;
            pV2 = tmp;
        }

        /// <summary>Write (append) specified text into specified file</summary>
        public static void ToLog(string pFilename, string pText)
        {
            using (StreamWriter sw = File.AppendText(pFilename))
            {
                sw.Write(pText);
            }
        }

        /// <summary>Remove piece of buffer, just in-place</summary>
        public static void BufferCut(Array pBuffer, int pCutLength)
        {
            int arrLength = pBuffer.GetLength(0);
            Array.Copy(pBuffer, pCutLength, pBuffer, 0, arrLength - pCutLength);
        }

        /// <summary>Remove piece of buffer, just in-place</summary>
        public static void BufferCut(Array pBuffer, int pOffset, int pCutLength)
        {
            int arrLength = pBuffer.GetLength(0);
            int shiftLen = arrLength - (pOffset + pCutLength);
            if (shiftLen <= 0) return;

            Array.Copy(pBuffer, pOffset + pCutLength, pBuffer, pOffset, shiftLen);
        }

        /// <summary>Build a string of bit-flag names which are turned on in specified FlagsValue</summary>
        public static string FlagsToStr(uint pFlagsValue, Type pEnumType)
        {
            string result = "";
            string[] names = Enum.GetNames(pEnumType);
            Array values = Enum.GetValues(pEnumType);
            for (int i = 0; i < names.Length; i++)
            {
                object v = values.GetValue(i);
                uint mask = (uint)Convert.ChangeType(v, typeof(uint));
                bool hasFlag = ((pFlagsValue & mask) != 0);
                if (hasFlag)
                    result += ((result.Length > 0 ? "," : "") + names[i]);
            }
            return result;
        }
    }

    /// <summary>Text trimming options</summary>
    public enum ETrimOption
    {
        None,
        Start,
        End,
        Both,
    }

    /// <summary>
    /// StrUtils - utilities to manipulate strings.
    /// </summary>
    public sealed class StrUtils
    {
        public static bool AUTO_TRIM_SPACES = true;

        /// <summary>Space characters (space, tab, CR, LF)</summary>
        public static string STR_SPACES = " \t\r\n";
        public static char[] CH_SPACES = STR_SPACES.ToCharArray();

        /// <summary>Digit characters</summary>
        public static string STR_DIGITS = "0123456789";
        public static char[] CH_DIGITS = STR_DIGITS.ToCharArray();

        /// <summary>Capital latin letters</summary>
        public static string STR_ALPHA_CHARS_CAPITAL = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        public static char[] CH_ALPHA_CHARS_CAPITAL = STR_ALPHA_CHARS_CAPITAL.ToCharArray();

        /// <summary>Small latin letters</summary>
        public static string STR_ALPHA_CHARS_SMALL = "abcdefghijklmnopqrstuvwxyz";
        public static char[] CH_ALPHA_CHARS_SMALL = STR_ALPHA_CHARS_SMALL.ToCharArray();

        /// <summary>All alpha chars (capital latin letters + small latin letters)</summary>
        public static string STR_ALPHA_CHARS = STR_ALPHA_CHARS_CAPITAL + STR_ALPHA_CHARS_SMALL;
        public static char[] CH_ALPHA_CHARS = STR_ALPHA_CHARS.ToCharArray();

        /// <summary>All alpha numeric chars (digits + capital latin letters + small latin letters)</summary>
        public static string STR_ALPHA_NUMERIC_CHARS = STR_DIGITS + STR_ALPHA_CHARS_CAPITAL + STR_ALPHA_CHARS_SMALL;
        public static char[] CH_ALPHA_NUMERIC_CHARS = STR_ALPHA_NUMERIC_CHARS.ToCharArray();

        /// <summary>Quote characters</summary>
        public static string STR_QUOTES = "\"\'";
        public static char[] CH_QUOTES = STR_QUOTES.ToCharArray();

        /// <summary>All chars in range \x00 .. \x1F</summary>
        public static string STR_SPECIAL_CHARS = "" + 
            "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F" +
            "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F" +
            "";
        public static char[] CH_SPECIAL_CHARS = STR_SPECIAL_CHARS.ToCharArray();

        // just all chars in range \x00..\x20 and ' ', '\"', ','
        public static string STR_QUOTABLE_CHARS = STR_SPECIAL_CHARS + " \",";
        public static char[] CH_QUOTABLE_CHARS = STR_QUOTABLE_CHARS.ToCharArray();

        /// <summary>Convert ID to case-insensitive form. The idea is to use this convertor for all CIS-identifiers in app</summary>
        /// <param name="pID">Identifier to convert to CIS-form</param>
        public static string GetCisID(string pID)
        {
            return pID.ToLower(); // StrUtils.FixIdentifier(
        }

        /// <summary>Fix null string (for log or dump output)</summary>
        /// <param name="pStr">String to check for null</param>
        /// <returns>Returns string as-is when not-null or "(null)" when string is null</returns>
        public static string FixNull(string pStr)
        {
            return (pStr != null ? pStr : "(null)");
        }

		/// <summary>
		/// Return string which is result of *pStr* concatencation *pCount* times.
		/// </summary>
		/// <param name="pStr">String to multiply</param>
		/// <param name="pCount">Number of times to repeat *pStr*</param>
		/// <returns>Result</returns>
		public static string Strng(string pStr, int pCount)
		{
			string txt = "";
			for (int i = 0; i < pCount; i++ )
				txt += pStr;
			return txt;
		}

		/// <summary>
        /// Present array of bytes as string with a list of hexadeciaml numbers.
        /// </summary>
        /// <param name="arr">Array of bytes</param>
        /// <param name="pDelimiter">Delimiter</param>
        /// <returns>String with a list of hexadeciaml numbers</returns>
        public static string Bytes2Hex(byte[] arr, string pDelimiter)
        {
            bool isEmptyDelim = string.IsNullOrEmpty(pDelimiter);
            StringBuilder sb = new StringBuilder(4 + arr.Length * 2);
            foreach (byte b in arr)
            {
                sb.Append(b.ToString("X2"));
                if (!isEmptyDelim)
                    sb.Append(pDelimiter);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Convert identifier to a text phrase, so insert a space at places before the capital letter in specified identifier.
        /// </summary>
        /// <param name="s">Identifier to convert</param>
        /// <returns>Converted identifier</returns>
        public static string NameToPhrase(string s)
        {
            int i = s.Length - 1;
            char ch = '\0', prevCh = '\0';
            while (i >= 0)
            {
                ch = s[i];
                bool isBigL = (ch >= 'A' && ch <= 'Z');
                bool isPrevSmallL = (prevCh >= 'a' && prevCh <= 'z');
                if (isBigL && isPrevSmallL)
                {
                    s = s.Insert(i, " "); 
                }

                prevCh = ch;
                i--;
            }
            return s;
        }

        /// <summary>
        /// Perform case-insensitive comparison to 2 strings
        /// </summary>
        /// <param name="s1">String 1 to compare</param>
        /// <param name="s2">String 2 to compare</param>
        /// <returns>True if String 1 equal to String 2, otherwise returns False.</returns>
        public static bool IsSameText(string s1, string s2)
        {
            return (string.Compare(s1, s2, true) == 0);
        }

        /// <summary>
        /// Perform case-sensitive comparison to 2 strings
        /// </summary>
        /// <param name="s1">String 1 to compare</param>
        /// <param name="s2">String 2 to compare</param>
        /// <returns>True if String 1 equal to String 2, otherwise returns False.</returns>
        public static bool IsSameStr(string s1, string s2)
        {
            return (string.Compare(s1, s2, false) == 0);
        }

        /// <summary>
        /// Returns True if string is null or empty.
        /// Deprecated! Please use standard string.IsNullOrEmpty() method instead!
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static bool IsEmptyStr(string s)
        {
            return (s == null || s == string.Empty);
        }

        /// <summary>
        ///  Adjust End-Of-Line delimiters in specified text.
        /// </summary>
        /// <param name="pText">Text to adjust EOL delimiters in</param>
        /// <param name="pNewEOL">New EOL delimiter to use</param>
        /// <returns>Test with adjusted EOL delimiters</returns>
        public static string AdjustLineBreaks(string pText, string pNewEOL)
        {
            pText = pText.Replace("\r\n", "\n").Replace('\r', '\n');
            if (pNewEOL != "\n")
                pText = pText.Replace("\n", pNewEOL);
            return pText;
        }

        public static string STR_VALID_ID_CHARS_1ST = STR_ALPHA_CHARS_CAPITAL + STR_ALPHA_CHARS_SMALL + "_";
        public static string STR_VALID_ID_CHARS = STR_VALID_ID_CHARS_1ST + STR_DIGITS;

        /// <summary>
        /// Check if specified identifier is valid.
        /// </summary>
        /// <param name="pID">The identifier to be validated.</param>
        /// <returns>Returns true if specified identifier is valid.</returns>
        public static bool IsValidIdentifier(string pID)
        {
            if (pID.Length == 0)
                return false;
            for (int i = 0; i < pID.Length; i++)
            {
                char ch = pID[i];
                bool isOk = (
                    (i == 0 && STR_VALID_ID_CHARS_1ST.IndexOf(ch) >= 0)
                    || (i > 0 && STR_VALID_ID_CHARS.IndexOf(ch) >= 0)
                    );
                if (!isOk)
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Fix all invalid chars in the identifier.
        /// So, it will replace all 'invalid chars' with '_' (underscore) char.
        /// </summary>
        /// <param name="pID">The identifier to validate and fix.</param>
        /// <returns>Fixed identifier.</returns>
        public static string FixIdentifier(string pID)
        {
            string fixedId = "";
            for (int i=0; i<pID.Length; i++)
            { 
                char ch = pID[i];
                bool isOk = (
                    (i == 0 && STR_VALID_ID_CHARS_1ST.IndexOf(ch) >= 0)
                    || (i > 0 && STR_VALID_ID_CHARS.IndexOf(ch) >= 0)
                    );
                if (!isOk)
                    fixedId += '_';
                else
                    fixedId += ch;
            }
            if (string.IsNullOrEmpty(fixedId))
                fixedId = "_";
            return fixedId;
        }

        /// <summary>Extract quoted part from string.</summary>
        /// <param name="pText">Source string to extract quoted part from</param>
        /// <param name="pQuotedPart">Output. Store extracted quoted part in</param>
        /// <returns>Returns position in source string where quoted part was extracted from or -1 when no more quoted parts found</returns>
        public static int ExtractQuotedPart(ref string pText, out string pQuotedPart)
        {
            int result = -1;
            pQuotedPart = null;
            result = pText.IndexOfAny(CH_QUOTES);
            if (result >= 0)
            {
                char quote = pText[result];
                // _123456
                // 'ORD'D4
                int resultFinish = pText.IndexOf(quote, result + 1);
                if (resultFinish >= 0)
                {
                    pQuotedPart = pText.Substring(result + 1, resultFinish - result - 1);
                    pText = pText.Remove(result, resultFinish - result + 1);
                }
            }
            return result;
        }

        /// <summary>Enclose string with specified quote char. If string already contains quote char it will add extra quotes to mask such</summary>
        /// <param name="S">String to enclosed with quotes</param>
        /// <param name="Quote">Quote char</param>
        /// <returns></returns>
        public static string AnsiQuotedStr(string S, char Quote)
        {
            int add_count = 0;
            int p = S.IndexOf(Quote);
            while (p >= 0)
            {
                add_count++;
                p = S.IndexOf(Quote, p + 1);
            }
            if (add_count == 0)
                return Quote + S + Quote;

            string text = S;
            p = text.IndexOf(Quote);
            while (p >= 0)
            {
                text = text.Insert(p, "" + Quote);
                p = text.IndexOf(Quote, p + 2);
            }
            return Quote + text + Quote;
        }

        /// <summary>Check is string is enclosed with specified char</summary>
        public static bool IsEnclosedWith(string s, char ch)
        {
            return (s.Length > 1 && (s[0] == ch && s[s.Length - 1] == ch));
        }

        /// <summary>Check is string is enclosed with specified chars (separate chars, at open and close)</summary>
        public static bool IsEnclosedWith(string s, char chOpen, char chClose)
        {
            return (s.Length > 1 && (s[0] == chOpen && s[s.Length - 1] == chClose));
        }

        /// <summary>
        /// Converts specified string to boolean value.
        /// </summary>
        /// <param name="s">String to convert</param>
        /// <returns>Returns True if source string is something which could be interpreted as True, so if it match one of following "true", "yes", "on", "1". Otherwise returns False.</returns>
        public static bool GetAsBool(string s)
        {
            s = s.Trim().ToLower();
            return (s == "yes" || s == "true" || s == "1" || s == "-1" || s == "on");
        }

        /// <summary>
        /// Convert specified string to boolean value.
        /// It recognize yes, true, on, 1 as true.
        /// And recognize no, false, off, 0 as false.
        /// </summary>
        /// <param name="s">String value to convert.</param>
        /// <param name="Value">Where to return a boolean value.</param>
        /// <returns>Returns true if boolean value was succesfully recognized. Otherwise returns false.</returns>
        public static bool GetAsBool(string s, out bool Value)
        {
            Value = false;
            s = s.Trim().ToLower();
            if (s == "yes" || s == "true" || s == "1" || s == "-1" || s == "on")
            {
                Value = true;
                return true;
            }
            else if (s == "no" || s == "false" || s == "0" || s == "off")
            {
                Value = false;
                return true;
            }
            return false;
        }

        //private static char[] _DIGITS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

        /// <summary>Convert specified string to integer value. It supports +,- also 0x prefix for hexadecimal</summary>
        /// <param name="s">String value to convert.</param>
        /// <param name="Value">Where to return an integer value.</param>
        /// <returns>Returns true if integer value was succesfully recognized. Otherwise returns false.</returns>
        public static bool GetAsInt(string s, out int Value)
        {
            Value = -1;
            if (string.IsNullOrEmpty(s)) return false;
            int sign = 0;
            if (s[0] == '-' || s[0] == '+') 
            {
                sign = (s[0] == '-' ? -1 : 1);
                s = s.Remove(0, 1);
            }
            if (string.IsNullOrEmpty(s)) return false;
            int numBase = 10;
            if (s.StartsWith("0x") || s.StartsWith("0X"))
            {
                numBase = 16;
                s = s.Remove(0, 2);
            }
            if (s.TrimEnd(CH_DIGITS) != string.Empty)
                return false;
            Value = Convert.ToInt32(s, numBase);
            if (sign < 0)
                Value *= sign;
            return true;
        }

        /// <summary>
        /// Convert specified string to long integer value.
        /// </summary>
        /// <param name="s">String value to convert.</param>
        /// <param name="Value">Where to return a long integer value.</param>
        /// <returns>Returns true if long integer value was succesfully recognized. Otherwise returns false.</returns>
        public static bool GetAsLong(string s, out long Value)
        {
            Value = -1;
            if (string.IsNullOrEmpty(s)) return false;
            int sign = 0;
            if (s[0] == '-' || s[0] == '+')
            {
                sign = (s[0] == '-' ? -1 : 1);
                s = s.Remove(0, 1);
            }
            if (string.IsNullOrEmpty(s)) return false;
            if (s.TrimEnd(CH_DIGITS) != string.Empty)
                return false;
            Value = Convert.ToInt64(s);
            if (sign < 0)
                Value *= sign;
            return true;
        }

        /// <summary>
        /// Convert specified string to double value.
        /// </summary>
        /// <param name="s">String value to convert.</param>
        /// <param name="Value">Where to return an double value.</param>
        /// <returns>Returns true if double value was succesfully recognized. Otherwise returns false.</returns>
        public static bool GetAsDouble(string s, out double Value)
        {
            if (Double.TryParse(s, out Value))
                return true;
            Value = 0;
            NumberFormatInfo nf = CultureInfo.CurrentCulture.NumberFormat;
            string altDecSep = nf.NumberDecimalSeparator;
            if (altDecSep == ",")
                altDecSep = ".";
            else
                altDecSep = ",";
            s = s.Replace(altDecSep, nf.NumberDecimalSeparator);
            if (Double.TryParse(s, out Value))
                return true;
            return false;
        }

        /// <summary>Return appropriate string for indexed enum name</summary>
        public static string IntToEnumName(int n, string pEnumNames)
        {
            string[] names = pEnumNames.Replace(';', ',').Split(',');
            return names[n % names.Length];
        }

        /// <summary>
        /// Convert specified string to integer number which is an index of a enumeration item in specified list.
        /// In other words - it converts string to enum value but returns enum value as integer.
        /// </summary>
        /// <param name="s">String value to convert.</param>
        /// <param name="pEnumNames">Comma-separated list of valid enum names</param>
        /// <param name="Value">Where to return an integer value.</param>
        /// <returns>Returns true if enum value was succesfully recognized. Otherwise returns false.</returns>
        public static bool GetAsEnum(string s, string pEnumNames, out int Value)
        {
            Value = -1;
            string[] names = pEnumNames.Split(',');
            for (int i=0; i<names.Length; i++)
            {
                if (string.Compare(s, names[i], true) == 0)
                {
                    Value = i;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Convert specified string to enum value of specified Type. In 
        /// </summary>
        /// <param name="s">String value to convert.</param>
        /// <param name="pEnumType">Type of target enum</param>
        /// <param name="Value">Where to return recognized enum value or null (if not recognized).</param>
        /// <returns>Returns true if enum value was succesfully recognized. Otherwise returns false.</returns>
        public static bool GetAsEnumEx(string s, Type pEnumType, out object Value)
        {
            Value = null;
            try
            {
                Value = Enum.Parse(pEnumType, s, true);
                return true;
            }
            catch { return false; }
        }

        /// <summary>
        ///  Try to convert specified string value into int value.
        ///  If fail returns the specified default value.
        /// </summary>
        /// <param name="s">String value to convert.</param>
        /// <param name="DefaultValue">DefaultValue to use if cannot convert</param>
        /// <returns>Integer value which is a result of string converting or DefaultValue if conversion fail</returns>
        public static int StrToIntDef(string s, int DefaultValue)
        {
            int n = DefaultValue;
            if (GetAsInt(s, out n))
                return n;
            return DefaultValue;
        }

        /// <summary>
        /// The same as StrToIntDef but works for long value.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="DefaultValue"></param>
        /// <returns></returns>
        public static long StrToLongDef(string s, long DefaultValue)
        {
            long n = DefaultValue;
            if (GetAsLong(s, out n))
                return n;
            return DefaultValue;
        }

        /// <summary>
        /// Returns a substring of N chars at right of specified source string.
        /// </summary>
        /// <param name="s">Source string</param>
        /// <param name="n">How many chars at right extract</param>
        /// <returns>Substring of N chars at right of specified source string</returns>
        public static string Right(string s, int n)
        {
            return s.Substring(s.Length-n, n);
        }

        /// <summary>
        /// Process specified string as a text (a set of EOL-separated items).
        /// Trim spaces in every item and concatenate them back
        /// </summary>
        /// <param name="pText">Text to trim lines in it</param>
        /// <param name="pTrimOption">An option defining where to trim spaces</param>
        /// <returns>Same text as input but consists of lines with trimmed spaces</returns>
        public static string TrimText(string pText, ETrimOption pTrimOption)
        {
            if (pTrimOption == ETrimOption.None)
                return pText;

            string eol = Environment.NewLine;
            if (pText.IndexOf("\r\n") >= 0)
                eol = "\r\n";
            else if (pText.IndexOf("\r") >= 0)
                eol = "\r";
            else if (pText.IndexOf("\n") >= 0)
                eol = "\n";

            if (eol != "\n")
                pText = pText.Replace(eol, "\n");

            StringBuilder sb = new StringBuilder(pText.Length);
            string[] lines = pText.Split('\n');
            foreach (string line in lines)
            {
                string s = line;
                switch (pTrimOption)
                {
                    case ETrimOption.Start: s = s.TrimStart(StrUtils.CH_SPACES); break;
                    case ETrimOption.End: s = s.TrimEnd(StrUtils.CH_SPACES); break;
                    case ETrimOption.Both: s = s.Trim(StrUtils.CH_SPACES); break;
                }
                sb.Append(s + eol);
            }
            return sb.ToString();
        }

        // *** Starting pattern

        /// <summary>
        /// Ensure that specified string has specified prefix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="ch">Prefix char to check and include if not found</param>
        /// <returns>Source string with prefix</returns>
        public static string IncludeStarting(string str, char ch)
        {
            return IncludeStarting(str, "" + ch);
        }

        /// <summary>
        /// Ensure that specified string has specified prefix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="pattern">Prefix substring to check and include if not found</param>
        /// <returns>Source string with prefix</returns>
        public static string IncludeStarting(string str, string pattern)
        {
            if (!str.StartsWith(pattern))
                return pattern + str;
            return str;
        }

        /// <summary>
        /// Ensure that specified string does not have specified prefix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="ch">Prefix char to check and exclude if found</param>
        /// <returns>Source string without a prefix</returns>
        public static string ExcludeStarting(string str, char ch)
        {
            return ExcludeStarting(str, "" + ch);
        }

        /// <summary>
        /// Ensure that specified string does not have specified prefix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="pattern">Prefix substring to check and exclude if found</param>
        /// <returns>Source string without a prefix</returns>
        public static string ExcludeStarting(string str, string pattern)
        {
            if (str.StartsWith(pattern))
                return str.Remove(0, pattern.Length);
            return str;
        }

        // *** Trailing pattern

        /// <summary>
        /// Ensure that specified string has specified suffix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="ch">Suffix char to check and include if not found</param>
        /// <returns>Source string with suffix</returns>
        public static string IncludeTrailing(string str, char ch)
        {
            return IncludeTrailing(str, "" + ch);
        }

        /// <summary>
        /// Ensure that specified string has specified suffix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="pattern">Suffix substring to check and include if not found</param>
        /// <returns>Source string with suffix</returns>
        public static string IncludeTrailing(string str, string pattern)
        {
            if (!str.EndsWith(pattern))
                return str + pattern;
            return str;
        }

        /// <summary>
        /// Ensure that specified string does not have specified suffix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="ch">Prefix char to check and exclude if found</param>
        /// <returns>Source string without a suffix</returns>
        public static string ExcludeTrailing(string str, char ch)
        {
            return ExcludeTrailing(str, "" + ch);
        }

        /// <summary>
        /// Ensure that specified string does not have specified suffix.
        /// </summary>
        /// <param name="str">Source string</param>
        /// <param name="pattern">Prefix substring to check and exclude if found</param>
        /// <returns>Source string without a suffix</returns>
        public static string ExcludeTrailing(string str, string pattern)
        {
            if (str.EndsWith(pattern))
                return str.Remove(str.Length - pattern.Length, pattern.Length);
            return str;
        }

        // *** String parsing

        /// <summary>
        /// Parse a text which is expected to be a {name} + {delimiter} + {value}.
        /// </summary>
        /// <param name="pStr">Source string to parse</param>
        /// <param name="pDelimiters">Which delimiters could be used to split name- and value- parts in source string</param>
        /// <param name="pName">Out: extracted name part</param>
        /// <param name="pValue">Out: extracted value part</param>
        /// <returns>Returns true is name and value successfully recognized</returns>
        public static bool ParseSingleNameValueItem(string pStr, string pDelimiters, out string pName, out string pValue)
        {
            pName = null;
            pValue = null;

            int p = pStr.IndexOfAny(pDelimiters.ToCharArray());
            if (p < 0) return false;

            pName = pStr.Substring(0, p).Trim(STR_SPACES.ToCharArray());
            pValue = pStr.Remove(0, p + 1).Trim(STR_SPACES.ToCharArray());

            return true;
        }

        /// <summary>Extract a part of string before the specified delimiter pattern. When pattern not found it returns null.</summary>
        /// <param name="pStr">Source string</param>
        /// <param name="pPattern">Delimiter pattern to search</param>
        /// <returns>Returns a part of string before the specified delimiter pattern or null delimiter pattern is not found</returns>
        public static string GetToPattern(string pStr, string pPattern)
        {
            int p = pStr.IndexOf(pPattern);
            if (p < 0) return null;

            return pStr.Substring(0, p);
        }

        /// <summary>Extract a part of string after the specified delimiter pattern</summary>
        /// <param name="pStr">Source string</param>
        /// <param name="pPattern">Delimiter pattern to search</param>
        /// <returns>Returns a part of string after the specified delimiter pattern or null delimiter pattern is not found</returns>
        public static string GetAfterPattern(string pStr, string pPattern)
        {
            int p = pStr.IndexOf(pPattern);
            if (p < 0) return null;

            return pStr.Remove(0, p + pPattern.Length);
        }

        /// <summary>
        /// Concatenate all items in specified string[] array using specified delimiter. 
        /// </summary>
        /// <param name="pItems">string[] array with items to concatenate</param>
        /// <param name="pDelimiter">Delimiter to use</param>
        /// <returns>String of concatenated array items</returns>
        public static string Join(string[] pItems, string pDelimiter)
        {
            return CollectionUtils.Join(pItems, pDelimiter);
        }

        /// <summary>
        /// Concatenate all items in specified Dictionary using specified delimiter and key-value separator. 
        /// </summary>
        /// <param name="pItems">Dictionary with items to concatenate</param>
        /// <param name="pDelimiter">Delimiter to use</param>
        /// <param name="pKeyValueSeparator">Separator for key+value</param>
        /// <returns>String of concatenated dictionary items</returns>
        public static string Join(Dictionary<string, string> pItems, string pDelimiter, string pKeyValueSeparator)
        {
            return CollectionUtils.Join(pItems, pDelimiter, pKeyValueSeparator);
        }

        /// <summary>
        /// Concatenate all items in specified Dictionary using specified item-template as a Format-template.
        /// </summary>
        /// <param name="pItems">Dictionary with items to concatenate</param>
        /// <param name="pItemTemplate">The string to be used as a Format-template (is to use use by string.Format(...) method)</param>
        /// <returns>String of concatenated dictionary items</returns>
        public static string JoinFormated(Dictionary<string, string> pItems, string pItemTemplate)
        {
            return CollectionUtils.JoinFormated(pItems, pItemTemplate);
        }

        public static void Merge(Dictionary<string, string> pTargetValues, Dictionary<string, string> pAdditionalValues, bool pForceLowerCaseNames)
        {
            CollectionUtils.Merge(pTargetValues, pAdditionalValues, pForceLowerCaseNames);
        }

        /// <summary>
        /// Expand macro parameters in specified string.
        /// The format of macro parameter in string is "$(" + {name} + ")".
        /// Example: "Hello, $(UserName)."
        /// Note: parameter names are not case sensitive.
        /// </summary>
        /// <param name="pStr">String to search and replace macro parameters in</param>
        /// <param name="pParams">Dictionary with a set of parameters (name + value pairs)</param>
        /// <param name="pExpandEnvironmentVars">If also it should expand environment variables</param>
        /// <returns></returns>
        public static string ExpandParameters(string pStr, Dictionary<string, string> pParams, bool pExpandEnvironmentVars)
        {
            if (pParams != null)
            {
                foreach (KeyValuePair<string, string> prm in pParams)
                {
                    int p;
                    string id;
                    do
                    {
                        id = "$(" + prm.Key.ToUpper() + ")";
                        string upStr = pStr.ToUpper();
                        p = upStr.IndexOf(id);
                        if (p < 0)
                        {
                            id = "${" + prm.Key.ToUpper() + "}";
                            p = upStr.IndexOf(id);
                        }
                        if (p >= 0)
                        {
                            string v = prm.Value;
                            if (v.ToUpper().ToUpper().CompareTo(id) == 0)
                                v = ""; // to avoid fall into endless loop when it may endlessly replace "$(DbServer)" with "$(DbServer)"! 
                            pStr = pStr.Remove(p, id.Length);
                            pStr = pStr.Insert(p, v);
                        }
                    }
                    while (p >= 0);
                }
            }

            if (pExpandEnvironmentVars)
                pStr = Environment.ExpandEnvironmentVariables(pStr);

            return pStr;
        }

        /// <summary>Deletegate method to return parameter value by specified parameter name</summary>
        /// <param name="pPrmName">Parameter name</param>
        /// <param name="pPrmValue">Output: parameter value</param>
        /// <param name="pContext">Context object</param>
        /// <returns>Returns true when parametrer found and value is valid</returns>
        public delegate bool GetParameterValueMethod(string pPrmName, out string pPrmValue, object pContext);

        /// <summary>
        /// Expand macro parameters in specified string.
        /// The format of macro parameter in string is {PrmOpenPattern} + {name} + {PrmClosePattern}.
        /// Examples: "Hello, $(UserName)." or "Hello, @UserName@."
        /// </summary>
        /// <param name="pStr">String to search and replace macro parameters in</param>
        /// <param name="pPrmOpenPattern">Parameter open-pattern, a pattern which beging parameter in string</param>
        /// <param name="pPrmClosePattern">Parameter close-pattern, a pattern which ends parameter in string</param>
        /// <param name="pGetPrmValue">Delegate which returns value for specified parameter name</param>
        /// <param name="pContext">Context object</param>
        /// <returns>Number of replaced parameters</returns>
        public static int ExpandParameters(ref string pStr, string pPrmOpenPattern, string pPrmClosePattern, GetParameterValueMethod pGetPrmValue, object pContext)
        {
            if (pGetPrmValue == null) return 0;

            int replaceCount = 0;
            int p1 = 0, p2;
            do
            {
                p1 = pStr.IndexOf(pPrmOpenPattern, p1);
                p2 = (p1 >= 0 ? pStr.IndexOf(pPrmClosePattern, p1 + pPrmOpenPattern.Length) : -1);
                if (p1 < 0 || p2 < 0) break;

                // _123456789_123456789
                // Hello, @user@.
                // Hello, $(user).
                string prmValue;
                string prmName = pStr.Substring(p1 + pPrmOpenPattern.Length, p2 - p1 - pPrmOpenPattern.Length);
                if (pGetPrmValue(prmName, out prmValue, pContext))
                {
                    pStr = pStr.Remove(p1, p2 - p1 + 1);
                    pStr = pStr.Insert(p1, prmValue);
                    replaceCount++;
                }
                else
                    p1 = p2 + pPrmClosePattern.Length;
            }
            while (p1 >= 0 && p2 >= 0);

            return replaceCount;
        }

        /// <summary>Parse string as INI-file (without sections). All item names will be force lowercased</summary>
        /// <param name="pText">Text to parse</param>
        /// <param name="pIniValues">Container to store extracted INI-parameters in</param>
        /// <returns>Amount of newly added named parameters into container</returns>
        public static int ParseIniValues(string pText, Dictionary<string, string> pIniValues)
        {
            int counter = pIniValues.Count;
            pText = pText.Replace("\r", "\n").Replace("\n\n", "\n");
            string[] lines = pText.Split('\n');
            foreach (string line in lines)
            {
                int p = line.IndexOf('=');
                if (p < 0) continue;

                string pn, pv;
                pn = line.Substring(0, p).Trim(StrUtils.CH_SPACES);
                pv = line.Remove(0, p + 1).Trim(StrUtils.CH_SPACES);

                pIniValues[pn.ToLower()] = pv;
            }
            return pIniValues.Count - counter;
        }

        /// <summary>Parse string as INI-file (without sections)</summary>
        /// <param name="pText">Text to parse</param>
        /// <param name="pIniValues">Container to store extracted INI-parameters in</param>
        /// <param name="pForceLowerCase">If need to force lowercase all item names</param>
        /// <returns>Amount of newly added named parameters into container</returns>
        public static int ParseIniValuesEx(string pText, Dictionary<string, string> pIniValues, bool pForceLowerCase)
        {
            int counter = pIniValues.Count;
            pText = pText.Replace("\r", "\n").Replace("\n\n", "\n");
            string[] lines = pText.Split('\n');
            foreach (string line in lines)
            {
                int p = line.IndexOf('=');
                if (p < 0) continue;

                string pn, pv;
                pn = line.Substring(0, p).Trim(StrUtils.CH_SPACES);
                pv = line.Remove(0, p + 1).Trim(StrUtils.CH_SPACES);

                pIniValues[pForceLowerCase ? pn.ToLower() : pn] = pv;
            }
            return pIniValues.Count - counter;
        }

        /// <summary>Parse LOP format string</summary>
        /// <param name="pText">Text to parse</param>
        /// <param name="pIniValues">Container to store extracted named parameters</param>
        /// <param name="pIgnoreCase">Force lower-case all parameter names</param>
        /// <returns>Amount of newly added named parameters into container</returns>
        public static int ParseLop(string pText, Dictionary<string, string> pIniValues, bool pIgnoreCase)
        {
            int counter = pIniValues.Count;
            string[] lines = pText.Split(';');
            foreach (string line in lines)
            {
                int p = line.IndexOf(':');
                if (p < 0) p = line.IndexOf('=');
                if (p < 0) continue;

                string pn, pv;
                pn = line.Substring(0, p).Trim(StrUtils.CH_SPACES);
                pv = line.Remove(0, p + 1);

                pIniValues[(pIgnoreCase ? pn.ToLower() : pn)] = pv;
            }
            return pIniValues.Count - counter;
        }

        /// <summary>Extract chars from specified string while string chars are exists in specified set of chars.</summary>
        /// <param name="pText">Source string to extract from. When non empty string extracted it will be removed from this string.</param>
        /// <param name="pChars">Set of 'valid chars' for extraction</param>
        /// <returns>Extracted string</returns>
        public static string ExtractWhile(ref string pText, string pChars)
        {
            int iCh = 0;
            string result = null;
            for (iCh = 0; iCh < pText.Length; iCh++)
            {
                char ch = pText[iCh];
                if (pChars.IndexOf(ch) < 0)
                    break;
                if (result == null) result = "";
                result += ch;
            }
            if (!string.IsNullOrEmpty(result))
            {
                pText = pText.Remove(0, iCh);
            }
            return result;
        }

        /// <summary>Extract chars from specified string until it finds any char which exists in specified set of chars.</summary>
        /// <param name="pText">Source string to extract from. When non empty string extracted it will be removed from this string.</param>
        /// <param name="pChars">Set of 'stop chars' for extraction</param>
        /// <returns>Extracted string</returns>
        public static string ExtractUntil(ref string pText, string pChars)
        {
            int iCh = 0;
            string result = null;
            for (iCh = 0; iCh < pText.Length; iCh++)
            {
                char ch = pText[iCh];
                if (pChars.IndexOf(ch) >= 0)
                    break;
                if (result == null) result = "";
                result += ch;
            }
            if (!string.IsNullOrEmpty(result))
            {
                pText = pText.Remove(0, iCh);
            }
            return result;
        }

        /// <summary>Case-insensitive replace</summary>
        /// <param name="pSource">Source string to search pOldPattern in</param>
        /// <param name="pOldPattern">Old text tattern to search and replace</param>
        /// <param name="pNewPattern">New text pattern to replace old text pattern</param>
        public static string ReplaceCI(string pSource, string pOldPattern, string pNewPattern)
        {
            pOldPattern = pOldPattern.ToLower();
            int p = pSource.ToLower().IndexOf(pOldPattern);
            while (p >= 0)
            {
                pSource = pSource.Remove(p, pOldPattern.Length);
                pSource = pSource.Insert(p, pNewPattern);

                p = pSource.ToLower().IndexOf(pOldPattern, p + 1);
            }
            return pSource;
        }

        /// <summary>
        /// Converts specified DateTime value into NSK-timestamp string
        /// </summary>
        /// <param name="pDT">DateTime value to convert</param>
        /// <returns>NSK-timestamp string</returns>
        public static string NskTimestampOf(DateTime pDT)
        {
            return string.Format("{0:0###}-{1:0#}-{2:0#}:{3:0#}:{4:0#}:{5:0#}.{6:0#####}",
                pDT.Year, pDT.Month, pDT.Day, pDT.Hour, pDT.Minute, pDT.Second, pDT.Millisecond * 1000);
        }

        /// <summary>Converts specified DateTime value into compat form of NSK-timestamp string (yyyyMMdd,hhnnss.ffffff)</summary>
        /// <param name="pDT">DateTime value to convert and compact</param>
        /// <returns>Compact form of NSK-timestamp string</returns>
        public static string CompactNskTimestampOf(DateTime pDT)
        {
            return string.Format("{0:0###}{1:0#}{2:0#},{3:0#}{4:0#}{5:0#}.{6:0#####}",
                pDT.Year, pDT.Month, pDT.Day, pDT.Hour, pDT.Minute, pDT.Second, pDT.Millisecond * 1000);
        }

        /// <summary>Compat form of NSK-timestamp string</summary>
        /// <param name="pTs">NSK timestamp to compart</param>
        /// <returns>Compact form of NSK-timestamp string</returns>
        public static string CompactNskTimestamp(string pTs)
        {
            // _123456789_123456789_12345
            // 20160324112233111222
            string ts = StripNskTimestamp(pTs);
            if (ts.Length > 8) ts = ts.Insert(8, ",");
            if (ts.Length > 15) ts = ts.Insert(15, ",");
            return ts;
        }

        /// <summary>
        /// Converts specified NSK-timestamp string to DateTime value.
        /// Note: it may lost precision, because .NET time fraction is milliseconds but NSK-timestamp fraction is microseconds.
        /// </summary>
        /// <param name="pTS">NSK-timestamp string to convert to DateTime value</param>
        /// <returns>DateTime value of specified NSK-timestamp string</returns>
        public static DateTime NskTimestampToDateTime(string pTS)
        {
            int y = 1900, m = 1, d = 1, h = 0, n = 0, s = 0, f = 0;

            // _123456789_123456789_12345
            // 2012-04-05:11:22:33.123456
            if (pTS.Length > 3) y = Convert.ToInt32(pTS.Substring(0, 4));
            if (pTS.Length > 6) m = Convert.ToInt32(pTS.Substring(5, 2));
            if (pTS.Length > 9) d = Convert.ToInt32(pTS.Substring(8, 2));
            if (pTS.Length > 12) h = Convert.ToInt32(pTS.Substring(11, 2));
            if (pTS.Length > 15) n = Convert.ToInt32(pTS.Substring(14, 2));
            if (pTS.Length > 18) s = Convert.ToInt32(pTS.Substring(17, 2));
            if (pTS.Length > 25) f = Convert.ToInt32(pTS.Substring(20, 6));

            return new DateTime(y, m, d, h, n, s, (int)(f / 1000));
        }

        /// <summary>
        /// Replace delimiter chars in NSK-timestamp string with specified delimiters.
        /// </summary>
        /// <param name="pTs">NSK-timestamp string to replace delimiters in</param>
        /// <param name="pDelimiters">Delimiters to use</param>
        /// <returns>NSK-timestamp string with replaced delimiters</returns>
        public static string ReplaceNskTimestampDelimiters(string pTs, string pDelimiters)
        {
            if (string.IsNullOrEmpty(pDelimiters)) 
                return pTs;

            int delimiterNo = 0;
            for (int i = 0; i < pTs.Length; i++)
            { 
                char ch = pTs[i];
                bool isDigit = (ch >= '0' && ch <= '9');
                if (isDigit) continue;
                if (delimiterNo >= pDelimiters.Length) delimiterNo = 0;
                pTs = pTs.Remove(i,1).Insert(i, "" + pDelimiters[delimiterNo]);
                delimiterNo++;
            }
            return pTs;
        }

        /// <summary>
        /// Remove all delimiter chars from specified NSK-timestamp string, so only digits left
        /// </summary>
        /// <param name="pTS">NSK-timestamp string</param>
        /// <returns>NSK-timestamp string with all removed delimiters</returns>
        public static string StripNskTimestamp(string pTS)
        {
            // _123456789_123456789_12345
            // 2012-03-30:11:22:33.444444
            if (pTS.Length > 19) pTS = pTS.Remove(19, 1);
            if (pTS.Length > 16) pTS = pTS.Remove(16, 1);
            if (pTS.Length > 13) pTS = pTS.Remove(13, 1);
            if (pTS.Length > 10) pTS = pTS.Remove(10, 1);
            if (pTS.Length > 7) pTS = pTS.Remove(7, 1);
            if (pTS.Length > 4) pTS = pTS.Remove(4, 1);
            return pTS;
        }

        /// <summary>
        /// Parse source string to extract a regular expression and modifiers from it.
        /// Expected source string will have a following format: '/' + {regular expression} + '/' + {modifiers string}.
        /// </summary>
        /// <param name="pStr">source string to parse.</param>
        /// <param name="pModifiers">Out: to return modifiers string into it</param>
        /// <returns>The Regex if source string was in correct format, otherwise - null.</returns>
        public static Regex ExtractRegexp(string pStr, out string pModifiers)
        { 
            pModifiers = null;

            bool hasModifiers = false;
            int p2 = 0, p1 = pStr.IndexOf('/');
            hasModifiers = (p1 == 0);
            if (hasModifiers)
            {
                p2 = pStr.LastIndexOf('/');
                hasModifiers = (p2 > 0 && p2 != p1);
            }

            if (!hasModifiers)
            {
                return new Regex(pStr);
            }

            // _12345678
            // /test/img
            pModifiers = pStr.Substring(p2 + 1, pStr.Length - p2 - 1).ToLower();
            pStr = pStr.Substring(0, p2).Remove(0, 1);

            RegexOptions opt = RegexOptions.None;
            int p = 0;
            bool isPositive = true;
            while (p < pModifiers.Length)
            {
                RegexOptions o = RegexOptions.None;
                char ch = pModifiers[p];
                p++;
                switch (ch)
                {
                    case 'e': o = RegexOptions.ExplicitCapture; break;
                    case 'i': o = RegexOptions.CultureInvariant | RegexOptions.IgnoreCase; break;
                    case 'm': o = RegexOptions.Multiline; break;
                    case 'r': o = RegexOptions.RightToLeft; break;
                    case 's': o = RegexOptions.IgnorePatternWhitespace; break;
                    case '-': isPositive = !isPositive; break;
                    default: continue;
                }
                if (isPositive)
                    opt |= o;
                else
                    opt &= ~o;
            }

            Regex rexp = new Regex(pStr, opt);
            return rexp;
        }

        /// <summary>
        /// Parse source string to extract a regular expression and modifiers from it.
        /// Expected source string will have a following format: '/' + {regular expression} + '/' + {modifiers string}.
        /// </summary>
        /// <param name="pStr">source string to parse.</param>
        /// <returns>The Regex if source string was in correct format, otherwise - null.</returns>
        public static Regex ExtractRegexp(string pStr)
        { 
            string s;
            return ExtractRegexp(pStr, out s);
        }

        /// <summary>Check and extract special directives from specified text/statement. In front of text could be some directives enclosed with chOpen/chClose chars</summary>
        /// <param name="pStmt">Text/statement to check and modify if special directives specified in it</param>
        /// <param name="pDirectives">Output variable to receive special directives</param>
        /// <returns>Returns true if special directives found and extracted</returns>
        public static bool ExtractSpecialDirectives(ref string pStmt, out string pDirectives, char chOpen = '{', char chClose = '}')
        {
            pDirectives = null;
            if (string.IsNullOrEmpty(pStmt)) return false;

            string text = pStmt;
            int p1 = text.IndexOf(chOpen);
            int p2 = text.IndexOf(chClose);
            bool isOk = (p1 >= 0 && p2 >= 0 && p1 < p2);
            if (!isOk) return false;

            pDirectives = text.Substring(p1 + 1, p2 - p1 - 1).Trim();
            pStmt = pStmt.Remove(0, p2 + 1);

            return true;
        }

        public static string STR_NUM_DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_~";

        /// <summary>Convert specified number to string in specified radix</summary>
        /// <param name="pNumber">Number to convert</param>
        /// <param name="pBase">Radix</param>
        public static string NumberToStr(uint pNumber, int pBase)
        {
            long n;
            int[] digits = new int[64];
            int i = 0, r;

            n = pNumber;
            while (Math.Abs(n) > pBase)
            {
                r = (int)(n % pBase);
                n = (int)(n / pBase);
                digits[i] = Math.Abs(r);
                i++;
            }
            if (Math.Abs(n) == pBase)
            {
                digits[i] = 0;
                i++; 
                n = 1;
            }
            digits[i] = (int)Math.Abs(n);

            string result = "";
            for (int j = i; j >= 0; j--)
            {
                result = result + STR_NUM_DIGITS[digits[j]];
            }
            return result;
        }

        /// <summary>Converts *filespec* to regex expression</summary>
        public static string FilespecToRexpStr(string pFileMask)
        {
            // convert filespecs to regular expression
            string rexpMask = pFileMask.Replace(".", "\\.");
            rexpMask = rexpMask.Replace("*", ".*");
            rexpMask = rexpMask.Replace("?", ".");
            return rexpMask;
        }

        /// <summary>Converts *filespec* to regex object</summary>
        public static Regex FilespecToRexp(string pFileMask)
        {
            Regex rexp = new Regex(FilespecToRexpStr(pFileMask), RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);
            return rexp;
        }

        // Character escapes and their replacements
        private static char[,] escChars = new char[10, 2] 
		{
			{'a', '\x07'}, {'b', '\x08'}, {'f', '\x0C'},
			{'t', '\x09'}, {'n', '\x0A'}, {'r', '\x0D'},
			{'v', '\x0B'}, {'\\', '\\'},  {'\'', '\''},
			{'\"', '\"'}
		};

        /// <summary>
        /// Check if passed string contains valid character escapes
        /// </summary>
        /// <param name="srcStr">String to be checked</param>
        /// <param name="realChar">Character by which character escapes should be replaced</param>
        /// <param name="len">Length of character escapes</param>
        /// <param name="escSeq">The string w/o character escapes</param>
        /// <returns>True if character escapes are valid</returns>
        public static bool IsValidEscSeq(string srcStr, out char realChar, out int len, out string escSeq)
        {
            if (srcStr == null || srcStr.Length == 0)
            {
                realChar = '\x00';
                len = 0;
                escSeq = "";
                return false;
            }

            bool result = true;
            string s = string.Empty;
            int j = 0;
            int n = 0;

            escSeq = string.Empty;
            len = 2;
            realChar = srcStr[0]; // ( (srcStr != null && srcStr.Length > 0) ? srcStr[0] : '\x00' ); <-- now validated before this code reached
            if (srcStr.Length < 2)
                return true;

            for (int i = 0; i < escChars.GetLength(0); i++)
            {
                if (srcStr[1] == escChars[i, 0])
                {
                    realChar = escChars[i, 1];
                    escSeq = srcStr.Substring(0, len);
                    return result;
                }
            }

            switch (srcStr[1])
            {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    {
                        j = 0;
                        len = srcStr.Length;
                        while ((j < 3) && ((j + 1) < len) && ("01234567".IndexOf(srcStr[j + 1]) >= 0))
                        {
                            s = s + srcStr[j + 1];
                            j++;
                        }
                        len = s.Length + 1;
                        realChar = (char)Convert.ToInt32(s, 8);
                        break;
                    }
                case 'x':
                    {
                        j = 0;
                        len = srcStr.Length;
                        while ((j < 2) && ((j + 2) < len) && (Uri.IsHexDigit(srcStr[j + 2])))
                        {
                            s = s + srcStr[j + 2];
                            j++;
                        }
                        len = s.Length + 2;
                        if (len == 1)
                            result = false;
                        else
                            realChar = (char)Convert.ToInt32(s, 16);
                        break;
                    }
                case 'd':
                    {
                        j = 0;
                        len = srcStr.Length;
                        while ((j < 5) && ((j + 2) < len) && char.IsDigit(srcStr[j + 2]))
                        {
                            s = s + srcStr[j + 2];
                            j++;
                        }
                        len = s.Length + 2;
                        if (len == 1)
                            result = false;
                        else
                        {
                            n = Convert.ToInt32(s);
                            realChar = (char)n;
                        }
                        break;
                    }
                default:
                    {
                        result = false;
                        escSeq = srcStr.Substring(0, len);
                        break;
                    }
            }
            if (result)
                escSeq = srcStr.Substring(0, len);

            return result;
        }

        /// <summary>Compile stirng - replace character escape-sequenced (C/C# style) with the their actual char values</summary>
        /// <param name="s">String to be compiled</param>
        /// <param name="disableToCompile">String of characters by which replacement should not be performed</param>
        /// <param name="ignoreError">Set to true to raise error for not valid character escapes</param>
        /// <returns>Compiled string</returns>
        public static string CompileStr(string s, string disableToCompile, bool ignoreError)
        {
            string result = string.Empty;
            string res = string.Empty;
            string errS = string.Empty;
            int len = s.Length;
            int i = 0;
            char realChar;
            while (i < len)
            {
                int seqLen = 1;
                if (s[i] == '\\')
                {
                    if (!IsValidEscSeq(s.Substring(i, s.Length - i), out realChar, out seqLen, out errS))
                    {
                        if (ignoreError)
                        {
                            realChar = s[i];
                            seqLen = 1;
                        }
                        else
                        {
                            i += seqLen;
                            if (i > len) i = len;
                            throw new XServiceError(String.Format("invalid escape sequence \"{0}\" in string \"{1}[...]\"",
                                errS, s.Substring(0, i)));
                        }
                    }
                    if (disableToCompile != null && disableToCompile.IndexOf(realChar) < 0)
                    {
                        res += realChar;
                    }
                    else
                    {
                        seqLen = 1;
                        res += s[i];
                    }
                }
                else
                {
                    res += s[i];
                }
                i += seqLen;
            }
            result = res;
            return result;
        }

        /// <summary>Compile stirng - replace character escape-sequenced (Borland Delphi style) with the their actual char values. Errors ignored</summary>
        /// <param name="pText">String to be compiled</param>
        /// <returns>Compiled string</returns>
        public static string CompileDelphi5Str(string pText)
        {
            string result = "";
            int iCh = 0;
            while (iCh < pText.Length)
            {
                char ch = pText[iCh];
                if (ch == '#')
                {
                    iCh++;
                    if (iCh >= pText.Length) break;
                    if (iCh < pText.Length && pText[iCh] == '#') { iCh--; break; }
                    char digit = pText[iCh];
                    bool isHex = (digit == '$');
                    if (isHex)
                    {
                        iCh++;
                        if (iCh >= pText.Length) break;
                        if (iCh < pText.Length && pText[iCh] == '#') { iCh--; break; }
                        digit = pText[iCh];
                    }
                    string chCodeStr = "" + digit;
                    int nChValue = 0;
                    while (true)
                    {
                        iCh++;
                        if (iCh >= pText.Length) break;
                        if (iCh < pText.Length && pText[iCh] == '#') { iCh--; break; }
                        digit = pText[iCh];
                        if (!isValidChDigit(digit, isHex)) { iCh--; break; }
                        chCodeStr += digit;
                        nChValue = Convert.ToInt32(chCodeStr, isHex ? 16 : 10);
                        if (nChValue > 255)
                        {
                            iCh--;
                            chCodeStr = chCodeStr.Substring(0, chCodeStr.Length - 1);
                            break;
                        }
                    }
                    nChValue = Convert.ToInt32(chCodeStr, isHex ? 16 : 10);
                    result += (char)nChValue;
                }
                else
                    result += ch;
                iCh++;
            }
            return result;
        }

        protected static bool isValidChDigit(char digit, bool isHex)
        {
            if (digit >= '0' && digit <= '9')
                return true;
            if (!isHex) return false;
            if ((digit >= 'A' && digit <= 'F') || (digit >= 'a' && digit <= 'f'))
                return true;
            return false;
        }

        private static string STR_STD_ESC_SEQUENCES = "\a\b\f\n\r\t\v";
        private static string[] ARR_STD_ESC_SEQUENCES = new string[] { "\\a", "\\b", "\\f", "\\n", "\\r", "\\t", "\\v" };

        /// <summary>Decompile string (this operation is opposite to CompileStr)</summary>
        /// <param name="s">String to decompile</param>
        /// <param name="forceDeCompile">Chars to be force decompiled</param>
        /// <returns>Decompiled string</returns>
        public static string DeCompileStr(string s, string forceDeCompile)
        {
            StringBuilder result = new StringBuilder(s.Length + 100);
            for (int i=0; i<s.Length; i++)
            {
                char ch = s[i];
                bool needDecompile = ( ('\x00' <= ch || ch <= '\x1F') || forceDeCompile.IndexOf(ch) >= 0 );
                if (needDecompile)
                {
                    int idx = STR_STD_ESC_SEQUENCES.IndexOf(ch);
                    if (idx >= 0)
                        result.Append(ARR_STD_ESC_SEQUENCES[idx]);
                    else 
                    {
                        uint chCode = (uint)ch;
                        if (chCode < 255)
                            result.Append("\\x" + chCode.ToString("X2"));
                        else
                            result.Append("\\x" + chCode.ToString("X"));
                    }
                }
                else
                    result.Append(ch);
            }
            return result.ToString();
        }

        /// <summary>Reverse a string</summary>
        /// <param name="s">string to reverse</param>
        /// <returns>Reversed string</returns>
        public static string Reverse(string s)
        {
            char[] charArray = s.ToCharArray();
            Array.Reverse( charArray );
            return new string( charArray );
        }

    } /* StrUtils */

    /// <summary>Set of routinues to operate text (assume "text" is a bit higher level abstraction of a string)</summary>
    public sealed class TextUtils
    {
        public static string ChangeEncoding(string pText, Encoding pSrcEnc, Encoding pTrgEnc)
        {
            byte[] data = pSrcEnc.GetBytes(pText);
            return pTrgEnc.GetString(data);
        }

        public static int DetermineUnicodePage(string pText)
        {
            int codepage = 0;
            for (int i = 0; i < pText.Length; i++)
            {
                int code = (int)pText[i];
                if (code > 255)
                {
                    codepage = (code >> 8);
                    return codepage;
                }
            }
            return codepage;
        }

		/// <summary>Convert Encoding ID string to Encoding object.</summary>
        /// <param name="pEncodingID">String representing Encoding ID. When starts with '#' it is expected to be a code page number. When starts with '@' it is expected to be a encoding name</param>
		/// <returns>Encoding object if Encoding ID was successfully recognized otherwise null</returns>
		public static Encoding StrToEncoding(string pEncodingID)
		{ 
			pEncodingID = pEncodingID.ToLower();
			
			if (pEncodingID == "ascii")
				return Encoding.ASCII;
			else if (pEncodingID == "bigendianunicode")
				return Encoding.BigEndianUnicode;
			else if (pEncodingID == "default")
				return Encoding.Default;
			else if (pEncodingID == "unicode")
				return Encoding.Unicode;
			else if (pEncodingID == "utf32")
				return Encoding.UTF32;
			else if (pEncodingID == "utf8")
				return Encoding.UTF8;
			else if (pEncodingID == "utf7")
				return Encoding.UTF7;

			if (pEncodingID.StartsWith("#"))
			{
				pEncodingID = pEncodingID.Remove(0, 1);
				int cp = Convert.ToInt32(pEncodingID);
				return Encoding.GetEncoding(cp);
			}

            if (pEncodingID.StartsWith("@"))
            {
                pEncodingID = pEncodingID.Remove(0, 1);
                return Encoding.GetEncoding(pEncodingID);
            }

            EncodingInfo[] encodings = Encoding.GetEncodings();
			foreach (EncodingInfo enc in encodings)
			{
				bool isMatch = (enc.Name.ToLower() == pEncodingID
					|| enc.DisplayName.ToLower() == pEncodingID
					|| enc.CodePage.ToString() == pEncodingID
					);
				if (isMatch)
					return enc.GetEncoding();
			}

			return null;
		}

        /// <summary>
        /// Try to guess what EOL (End-Of-Line) marker is used in specified text.
        /// </summary>
        /// <param name="pText">Source text to check for EOL</param>
        /// <returns>EOL value</returns>
        public static string DiscoverEOL(string pText)
        {
            int nCR = pText.IndexOf('\r');
            int nLF = pText.IndexOf('\n');
            if (nCR >= 0 && nLF >= 0)
                return "\r\n";
            else if (nCR >= 0)
                return "\r";
            else if (nLF >= 0)
                return "\n";
            else
                return Environment.NewLine;
        }

        /// <summary>Trim starting and trailing spaced in each line in specified text</summary>
        public static string RepackText(string pText)
        {
            StringBuilder sb = new StringBuilder(pText.Length);
            List<string> text = new List<string>(StrUtils.AdjustLineBreaks(pText, "\n").Split('\n'));
            for (int i = 0; i < text.Count; i++)
            {
                text[i] = text[i].Trim(StrUtils.CH_SPACES);
                sb.AppendLine(text[i]);
            }
            return sb.ToString();
        }

    }

    /*
    * Cannot use this because it required ref to System.Core which will make it force-bound to .NET 3.5 or higher! 
    public static class Extensions
    {
        public static void Init<T>(this T[] array, T value)
        {
            for (int i = 0; i < array.Length; ++i)
            {
                array[i] = value;
            }
        }

        /// <summary>Slice array</summary>
        public static T[] Slice<T>(this T[] arr, uint indexFrom, uint indexTo)
        {
            if (indexFrom > indexTo)
            {
                throw new ArgumentOutOfRangeException("indexFrom is bigger than indexTo!");
            }
            if (indexFrom < 0 || indexFrom >= arr.Length)
            {
                throw new ArgumentOutOfRangeException(string.Format("indexFrom ({0}) is out of array bounds [{1} .. {2}]", indexFrom, 0, arr.Length));
            }

            uint length = indexTo - indexFrom;
            T[] result = new T[length];
            Array.Copy(arr, indexFrom, result, 0, length);

            return result;
        }

    }*/



}
